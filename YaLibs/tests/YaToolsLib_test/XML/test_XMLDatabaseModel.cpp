//  Copyright (C) 2017 The YaCo Authors
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <iostream>

#include "IModelVisitor.hpp"


#ifndef YALIB_TEST
#   define YALIB_TEST
#endif

#include "test_common.hpp"
#include "XML/XMLDatabaseModel.hpp"
#include "ExporterValidatorVisitor.hpp"
#include "XML/XMLExporter.hpp"
#include "XML/common.hpp"
#include "IModel.hpp"
#include "Model.hpp"

#include "gtest/gtest.h"
#include <queue>
#include <fstream>

#ifdef _MSC_VER
#   include <filesystem>
#else
#   include <experimental/filesystem>
#endif

using namespace std;
using namespace experimental::filesystem;

int TestInTempFolder::index = 0;

class TestXMLDatabaseModel : public TestInTempFolder {
protected:
    virtual void SetUp() {
        TestInTempFolder::SetUp();
    }

    virtual void TearDown() {
        TestInTempFolder::TearDown();
    }
};

TEST_F (TestXMLDatabaseModel, TestFiles) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>2223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x00000000000000C</size>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">EF28578A</signature>\n\
      </signatures>\n\
      <offsets/>\n\
      <xrefs/>\n\
      <matchingsystem>\n\
        <address>00000038</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_id()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_size()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_signature()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_TRUE(call_queue->empty());


}

TEST_F (TestXMLDatabaseModel, TestFilesValidator) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>2223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000000C</size>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">EF28578A</signature>\n\
      </signatures>\n\
      <offsets/>\n\
      <xrefs/>\n\
      <matchingsystem>\n\
        <address>00000038</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>";
    test_input.close();

    auto visitor = MakeExporterValidatorVisitor();
    std::vector<std::string> input_files {filename.string()};
    auto model = MakeXmlFilesDatabaseModel(input_files);
    EXPECT_NO_THROW(model->accept(*visitor));
}

TEST_F (TestXMLDatabaseModel, TestOneDoubleFile) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>2223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000000C</size>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">EF28578A</signature>\n\
      </signatures>\n\
      <offsets/>\n\
      <xrefs/>\n\
      <matchingsystem>\n\
        <address>00000038</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
  <basic_block>\n\
    <id>2223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000000C</size>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">EF28578A</signature>\n\
      </signatures>\n\
      <offsets/>\n\
      <xrefs/>\n\
      <matchingsystem>\n\
        <address>00000038</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());


    EXPECT_STREQ(call_queue->front().c_str(), "visit_start()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_id()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_size()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_signature()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());

    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_id()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_size()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_signature()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_signatures()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_offsets()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_xrefs()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_start_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_matching_system_description()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_system()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_matching_systems()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_object_version()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end_reference_object()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_STREQ(call_queue->front().c_str(), "visit_end()");
    EXPECT_NO_THROW(call_queue->pop());
    EXPECT_TRUE(call_queue->empty());

}

TEST_F (TestXMLDatabaseModel, TestOneFileWithBlob) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <segment>\n\
    <id>3223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x0000000000000C9B</size>\n\
      <userdefinedname>.text</userdefinedname>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000000\">0123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000487\">1123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000490\">2123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004A3\">3123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004B0\">4123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000067C\">5123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000680\">6123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000790\">7123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000095A\">8123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000960\">9123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A34\">A123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A40\">B123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BDC\">C123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BE0\">D123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C03\">E123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C10\">F123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C76\">0223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C80\">1223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000008000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
      <attribute key=\"org_base\">0</attribute>\n\
      <attribute key=\"comb\">2</attribute>\n\
      <attribute key=\"color\">4294967295</attribute>\n\
      <attribute key=\"align\">3</attribute>\n\
      <attribute key=\"start_ea\">134217728</attribute>\n\
      <attribute key=\"perm\">5</attribute>\n\
      <attribute key=\"bitness\">1</attribute>\n\
      <attribute key=\"flags\">16</attribute>\n\
      <attribute key=\"end_ea\">134220955</attribute>\n\
      <attribute key=\"sel\">1</attribute>\n\
      <attribute key=\"type\">2</attribute>\n\
      <blob offset=\"0000000000000012\">5557565381EC4C0100008B8424600100008DA8800000000580800000894424348B842460010000896C24300580000100894424388B84246001000005808001008944243CA1A00C000885C00F8531040000B8D48D000885C07409C70424A40C0008FFD0A1A00C000885C00F84A3010000B8D88D000885C07409C70424A40C0008FFD0C744240800000200C744240400000000892C24E8428D0000C744241C18000000C744242C000000008B44242CC7442424000000008D3C85000000008B6C44308D048504000000897C2428894424208B5C242489D889DAC1F80483E20183E00209D089DA03442428D1FA83E20FC1E00401D089DA8B3C85E07F0008C1E20631DB89542414C1E704897C24188D74260089D889DA0FB64C241CC1F80483E2018B74241883E00209D089DA03442420D1FA83E20FC1E00401D00B3485E07F00088B442414D3E689F1C1E91809D88B3CCDC02C0008C1E00383C3018B0CCDC42C00088D5405008D440504893A890889F1C1E9100FB6C98B3CCDC0340008093A8B0CCDC4340008090889F10FB6CD8B3CCDC03C0008093A8B0CCDC43C0008090889F10FB6F18B0CF5C0440008090A8B14F5C4440008091083FB400F8553FFFFFF8344242401837C2424400F8503FFFFFF8344242C02836C241C08837C242C080F85C8FEFFFF8B842460010000C7809000020000000000C6808E00020000C6808F000200008380980002000181C44C0100005B5E5F5DC3BAC05C0008B90008000089D731DBF3AB8B3C9D208A000889D98D77FF83C70689F2C1FA1FC1EA1D8D041683E00729D00FB680617D000889442414B893244992F7EB89D8C1F81F01DAC1FA0429C26BC21C29C185F60F48F78B048DF07C00088B4C2414C1FE038D347231D2C1E60983C20181FA80000000741685D174F1098496C05C000883C20181FA8000000075EA83C30183FB380F8576FFFFFFBAC04C0008B90004000031C089D7F3AB30DBBF932449928B049D208900088D48FF89C8F7EF89C8C1F81F8D340AC1FE0229C68D04F50000000029F029C1B8ABAAAA2AF7EB89D80FB689617D0008C1F81FC1E609C1FA0229C28D045289DAC1E00329C28B0495807D000831D283C20181FA80000000741685D174F1098496C04C000883C20181FA8000000075EA83C30183FB307583BAC02C0008B90008000031C089D7F3AB30DB8B049D60880008BFABAAAA2A8B3485DC87000883EE0189F083E0070FB688607D000889D8F7EF89D8C1F81F89DFC1EE03C1E609C1FA0229C289D08D145201C6C1E203B8FF00000029D789FAC1E6028DB4260000000085C8740E8B3C95807D000809BCC6C02C000883E80183F8FF75E683C30183FB307589B82F000000EB0B8DB4260000000089C389D08B14856088000883C32F8944943C899C94BC0000008D50FF83FAFF75DFBAC00C0008B90008000031C089D7F3AB31DBBFABAAAA2A8B049DE07D00088B4C843C89C8F7EF89C8C1F81F29C28D045201C029C189D883E01F8B0C8D487D00088B3485E07C000889D8C1F805C1E20701C2B83F000000C1E2028DB60000000085C8740709B4C2C00C000883E80183F8FF75ED83C30183FB40759DC705A00C000801000000E9EEFBFFFFE9FBFBFFFF89F68DBC270000000083EC1CC70424288D0008E861FBFFFF83C41CC38DB6000000008DBC27000000005557565383EC1C8B4424348B5C24308B909800020085D20F84800100000FB6033C5A7F1C3C417D208D50D280FA0B761831C083C41C5B5E5F5DC38DB6000000008D509F80FA1977E80FB6530180FA5A0F8F3701000080FA417D088D4AD280F90B77CE8B4C243438818E0002000F84400100008B4C243489DF31DB88818E00020088918F00020031C90FBE073C608D50C57F0B3C408D50CB0F8E0D01000031C0900FA3C2730A8D34080B1CB5807D000883C00183F80675E983C10683C70183F90C75C68B4424348B7424348B889000020083E8808DAE8080000031D9908D7426008B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80800100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000200908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B44243489989000020083C41CB8010000005B5E5F5DC38D4A9F80F9190F8798FEFFFFE9C5FEFFFF890424E8ABF9FFFFE973FEFFFF8D50D2E9EBFEFFFF8B4C243438918F0002000F85B0FEFFFFB801000000E966FEFFFF8D74260055B9C05C00085731D25631C0538B5C24148B6C24188D76000FB63383C30183E67F0B04B10B94B10002000081C10004000081F9C07C000875DF31F6908D7426000FB60CB5E0890008BF1C00000089C32B3CB5E089000883C508D3E389F9D3E809D889C389C183E37F8B1C9DC0520008C1E91583E17F80CF800B1C8DC04C000889C1C1E90E83E17F0B1C8DC04E000889C1C1E90783E17F0B1C8DC05000080FB60CB5E089000883C601895DF889D3D3E389F9D3EA09DA89D189D383E17F8B0C8DC05A0008C1EB1583E37F80CD800B0C9DC054000889D3C1EB0E83E37F0B0C9DC056000889D3C1EB0783E37F0B0C9DC058000883FE10894DFC0F8543FFFFFF8B442418C78094000200000000005B5E5F5DC35557565383EC108B4C24248B4424288B71048B298B98900002008B790C89F08B510831E821D831C531F089C689F831D021D889F331C731C289E8C1E8038954240CC1EB03896C240489D589FA89042489F8C1ED03C1EA03C1E8098974240883E03F89EE89D58B14C5C028000883E63F83E53F8B04C5C42800080B14EDC02A00080B04EDC42A000889FDC1ED13C1EF1983E53F83E73F0B14EDC02600080B04EDC42600080B14FDC02400080B04FDC42400088B7C240C0B14F5C02200080B04F5C422000889FDC1ED0989EE89FD83E63F0B14F5C02000080B04F5C4200008C1ED1383E33F89EE89FD83E63FC1ED190B14F5C01E00080B04F5C41E000889EE83E63F0B14F5C01C00080B04F5C41C00088B7424080B14DDC01A00080B04DDC41A000889F3C1EB0983E33F0B14DDC01800080B04DDC418000889F3C1EB1383E33F0B14DDC01600080B04DDC416000889F3C1EB1983E33F0B14DDC01400080B04DDC41400088324243F8B7C24048B342489FBC1EB0983E33F0B14F5C01200080B04F5C41200080B14DDC01000080B04DDC410000889FBC1EB1383E33F0B14DDC00E00080B04DDC40E000889FBC1EB1983E33F0B04DDC40C00080B14DDC00C0008894104891183C4105B5E5F5DC38DB600000000555756538B54241C8B7C24208B7424148B6C24180FB6028887800002000FB6420184C075030FB6028B7C2420B91A00000088878100020089FA89F0D3E883E03F83F8258D583B770C8D583583F80C8D782E0F42DF83E90683C201889A8100020083F9FC75D48B54242089EFB91A00000083E70FC1ED02C1E61EC1E70209EE89F0D3E883E03F83F8258D583B770C8D583583F80C8D682E0F42DD83E90683C201889A8600020083F9FC75D483FF258D473B7F0C8D473583FF0C8D572E0F4CC28B74242088868C000200C6868D000200005B5E5F5DC38DB6000000008DBF000000005557565383EC2C8B442448C70424C07C00088B7424448B5C244089442404E84DFAFFFF8B44244885F60F94C28B809400020085C00F94C038C2743A8B542448B80800000089D166908B2A83C2088B7CC138896CC1388B6AFC897AF88B7CC13C896CC13C897AFC83E80175DD8B44244889B09400020031C031ED8DB426000000008B1485608800088B1495DC7E0008807C13FF0074070B2C85807D000883C00183F81875DC31F666908B1485608800088B1495DC7E0008807C13FF0074070B3485207D000883C00183F83075DC30C031FF8B1485608800088B14955C7F0008807C13FF0074070B3C85807D000883C00183F81875DC31C966908B1485608800088B14955C7F0008807C13FF0074070B0C85207D000883C00183F83075DC8B442448897424148D74241089742408C704240100000089442404894C241C896C2410897C2418E8588200008B44244889342489442404E8F8FBFFFF8B4C241031C08B5424148DB600000000850C85E07C00080F95040383C00183F82075ED30C08D7600851485E07C00080F9544032083C00183F82075EC83C42C5B5E5F5DC38D74260083EC1C8B442424C7442408288D0008894424048B442420890424E841FEFFFF83C41CC38DB6000000008DBC27000000005557565383EC2C8B5C24448D6C2418C70424C07C00088B7424408D7C2420895C2404E879F8FFFF89E98DB426000000008D560831C08D760083C60101C00A46FF39F275F4D0E883C1018841FF39F989D675DE895C2404892C24E812FAFFFF83C42C5B5E5F5DC38D76008DBC270000000083EC1C8B442420C7442404288D0008890424E879FFFFFF83C41CC3</blob>\n\
    </version>\n\
  </segment>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/segment/3223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}



TEST_F (TestXMLDatabaseModel, TestOneFileWithComment) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <segment>\n\
    <id>3223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x0000000000000C9B</size>\n\
      <userdefinedname>.text</userdefinedname>\n\
      <offsets>\n\
        <comments offset=\"0000000000000000\" type=\"nonrepeatable_comment\">Copy of shared data</comments>\n\
      </offsets>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000000\">0123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000487\">1123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000490\">2123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004A3\">3123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004B0\">4123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000067C\">5123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000680\">6123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000790\">7123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000095A\">8123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000960\">9123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A34\">A123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A40\">B123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BDC\">C123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BE0\">D123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C03\">E123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C10\">F123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C76\">0223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C80\">1223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000008000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
      <attribute key=\"org_base\">0</attribute>\n\
      <attribute key=\"comb\">2</attribute>\n\
      <attribute key=\"color\">4294967295</attribute>\n\
      <attribute key=\"align\">3</attribute>\n\
      <attribute key=\"start_ea\">134217728</attribute>\n\
      <attribute key=\"perm\">5</attribute>\n\
      <attribute key=\"bitness\">1</attribute>\n\
      <attribute key=\"flags\">16</attribute>\n\
      <attribute key=\"end_ea\">134220955</attribute>\n\
      <attribute key=\"sel\">1</attribute>\n\
      <attribute key=\"type\">2</attribute>\n\
      <blob offset=\"0000000000000012\">5557565381EC4C0100008B8424600100008DA8800000000580800000894424348B842460010000896C24300580000100894424388B84246001000005808001008944243CA1A00C000885C00F8531040000B8D48D000885C07409C70424A40C0008FFD0A1A00C000885C00F84A3010000B8D88D000885C07409C70424A40C0008FFD0C744240800000200C744240400000000892C24E8428D0000C744241C18000000C744242C000000008B44242CC7442424000000008D3C85000000008B6C44308D048504000000897C2428894424208B5C242489D889DAC1F80483E20183E00209D089DA03442428D1FA83E20FC1E00401D089DA8B3C85E07F0008C1E20631DB89542414C1E704897C24188D74260089D889DA0FB64C241CC1F80483E2018B74241883E00209D089DA03442420D1FA83E20FC1E00401D00B3485E07F00088B442414D3E689F1C1E91809D88B3CCDC02C0008C1E00383C3018B0CCDC42C00088D5405008D440504893A890889F1C1E9100FB6C98B3CCDC0340008093A8B0CCDC4340008090889F10FB6CD8B3CCDC03C0008093A8B0CCDC43C0008090889F10FB6F18B0CF5C0440008090A8B14F5C4440008091083FB400F8553FFFFFF8344242401837C2424400F8503FFFFFF8344242C02836C241C08837C242C080F85C8FEFFFF8B842460010000C7809000020000000000C6808E00020000C6808F000200008380980002000181C44C0100005B5E5F5DC3BAC05C0008B90008000089D731DBF3AB8B3C9D208A000889D98D77FF83C70689F2C1FA1FC1EA1D8D041683E00729D00FB680617D000889442414B893244992F7EB89D8C1F81F01DAC1FA0429C26BC21C29C185F60F48F78B048DF07C00088B4C2414C1FE038D347231D2C1E60983C20181FA80000000741685D174F1098496C05C000883C20181FA8000000075EA83C30183FB380F8576FFFFFFBAC04C0008B90004000031C089D7F3AB30DBBF932449928B049D208900088D48FF89C8F7EF89C8C1F81F8D340AC1FE0229C68D04F50000000029F029C1B8ABAAAA2AF7EB89D80FB689617D0008C1F81FC1E609C1FA0229C28D045289DAC1E00329C28B0495807D000831D283C20181FA80000000741685D174F1098496C04C000883C20181FA8000000075EA83C30183FB307583BAC02C0008B90008000031C089D7F3AB30DB8B049D60880008BFABAAAA2A8B3485DC87000883EE0189F083E0070FB688607D000889D8F7EF89D8C1F81F89DFC1EE03C1E609C1FA0229C289D08D145201C6C1E203B8FF00000029D789FAC1E6028DB4260000000085C8740E8B3C95807D000809BCC6C02C000883E80183F8FF75E683C30183FB307589B82F000000EB0B8DB4260000000089C389D08B14856088000883C32F8944943C899C94BC0000008D50FF83FAFF75DFBAC00C0008B90008000031C089D7F3AB31DBBFABAAAA2A8B049DE07D00088B4C843C89C8F7EF89C8C1F81F29C28D045201C029C189D883E01F8B0C8D487D00088B3485E07C000889D8C1F805C1E20701C2B83F000000C1E2028DB60000000085C8740709B4C2C00C000883E80183F8FF75ED83C30183FB40759DC705A00C000801000000E9EEFBFFFFE9FBFBFFFF89F68DBC270000000083EC1CC70424288D0008E861FBFFFF83C41CC38DB6000000008DBC27000000005557565383EC1C8B4424348B5C24308B909800020085D20F84800100000FB6033C5A7F1C3C417D208D50D280FA0B761831C083C41C5B5E5F5DC38DB6000000008D509F80FA1977E80FB6530180FA5A0F8F3701000080FA417D088D4AD280F90B77CE8B4C243438818E0002000F84400100008B4C243489DF31DB88818E00020088918F00020031C90FBE073C608D50C57F0B3C408D50CB0F8E0D01000031C0900FA3C2730A8D34080B1CB5807D000883C00183F80675E983C10683C70183F90C75C68B4424348B7424348B889000020083E8808DAE8080000031D9908D7426008B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80800100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000200908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B44243489989000020083C41CB8010000005B5E5F5DC38D4A9F80F9190F8798FEFFFFE9C5FEFFFF890424E8ABF9FFFFE973FEFFFF8D50D2E9EBFEFFFF8B4C243438918F0002000F85B0FEFFFFB801000000E966FEFFFF8D74260055B9C05C00085731D25631C0538B5C24148B6C24188D76000FB63383C30183E67F0B04B10B94B10002000081C10004000081F9C07C000875DF31F6908D7426000FB60CB5E0890008BF1C00000089C32B3CB5E089000883C508D3E389F9D3E809D889C389C183E37F8B1C9DC0520008C1E91583E17F80CF800B1C8DC04C000889C1C1E90E83E17F0B1C8DC04E000889C1C1E90783E17F0B1C8DC05000080FB60CB5E089000883C601895DF889D3D3E389F9D3EA09DA89D189D383E17F8B0C8DC05A0008C1EB1583E37F80CD800B0C9DC054000889D3C1EB0E83E37F0B0C9DC056000889D3C1EB0783E37F0B0C9DC058000883FE10894DFC0F8543FFFFFF8B442418C78094000200000000005B5E5F5DC35557565383EC108B4C24248B4424288B71048B298B98900002008B790C89F08B510831E821D831C531F089C689F831D021D889F331C731C289E8C1E8038954240CC1EB03896C240489D589FA89042489F8C1ED03C1EA03C1E8098974240883E03F89EE89D58B14C5C028000883E63F83E53F8B04C5C42800080B14EDC02A00080B04EDC42A000889FDC1ED13C1EF1983E53F83E73F0B14EDC02600080B04EDC42600080B14FDC02400080B04FDC42400088B7C240C0B14F5C02200080B04F5C422000889FDC1ED0989EE89FD83E63F0B14F5C02000080B04F5C4200008C1ED1383E33F89EE89FD83E63FC1ED190B14F5C01E00080B04F5C41E000889EE83E63F0B14F5C01C00080B04F5C41C00088B7424080B14DDC01A00080B04DDC41A000889F3C1EB0983E33F0B14DDC01800080B04DDC418000889F3C1EB1383E33F0B14DDC01600080B04DDC416000889F3C1EB1983E33F0B14DDC01400080B04DDC41400088324243F8B7C24048B342489FBC1EB0983E33F0B14F5C01200080B04F5C41200080B14DDC01000080B04DDC410000889FBC1EB1383E33F0B14DDC00E00080B04DDC40E000889FBC1EB1983E33F0B04DDC40C00080B14DDC00C0008894104891183C4105B5E5F5DC38DB600000000555756538B54241C8B7C24208B7424148B6C24180FB6028887800002000FB6420184C075030FB6028B7C2420B91A00000088878100020089FA89F0D3E883E03F83F8258D583B770C8D583583F80C8D782E0F42DF83E90683C201889A8100020083F9FC75D48B54242089EFB91A00000083E70FC1ED02C1E61EC1E70209EE89F0D3E883E03F83F8258D583B770C8D583583F80C8D682E0F42DD83E90683C201889A8600020083F9FC75D483FF258D473B7F0C8D473583FF0C8D572E0F4CC28B74242088868C000200C6868D000200005B5E5F5DC38DB6000000008DBF000000005557565383EC2C8B442448C70424C07C00088B7424448B5C244089442404E84DFAFFFF8B44244885F60F94C28B809400020085C00F94C038C2743A8B542448B80800000089D166908B2A83C2088B7CC138896CC1388B6AFC897AF88B7CC13C896CC13C897AFC83E80175DD8B44244889B09400020031C031ED8DB426000000008B1485608800088B1495DC7E0008807C13FF0074070B2C85807D000883C00183F81875DC31F666908B1485608800088B1495DC7E0008807C13FF0074070B3485207D000883C00183F83075DC30C031FF8B1485608800088B14955C7F0008807C13FF0074070B3C85807D000883C00183F81875DC31C966908B1485608800088B14955C7F0008807C13FF0074070B0C85207D000883C00183F83075DC8B442448897424148D74241089742408C704240100000089442404894C241C896C2410897C2418E8588200008B44244889342489442404E8F8FBFFFF8B4C241031C08B5424148DB600000000850C85E07C00080F95040383C00183F82075ED30C08D7600851485E07C00080F9544032083C00183F82075EC83C42C5B5E5F5DC38D74260083EC1C8B442424C7442408288D0008894424048B442420890424E841FEFFFF83C41CC38DB6000000008DBC27000000005557565383EC2C8B5C24448D6C2418C70424C07C00088B7424408D7C2420895C2404E879F8FFFF89E98DB426000000008D560831C08D760083C60101C00A46FF39F275F4D0E883C1018841FF39F989D675DE895C2404892C24E812FAFFFF83C42C5B5E5F5DC38D76008DBC270000000083EC1C8B442420C7442404288D0008890424E879FFFFFF83C41CC3</blob>\n\
    </version>\n\
  </segment>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/segment/3223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}




TEST_F (TestXMLDatabaseModel, TestOneFileWithAccentuatedComment) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <segment>\n\
    <id>3223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x0000000000000C9B</size>\n\
      <userdefinedname>.text</userdefinedname>\n\
      <offsets>\n\
        <comments offset=\"0000000000000000\" type=\"nonrepeatable_comment\">Copy of shared data</comments>\n\
      </offsets>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000000\">0123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000487\">1123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000490\">2123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004A3\">3123456789ABCDEF</xref>\n\
        <xref offset=\"0x00000000000004B0\">4123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000067C\">5123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000680\">6123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000790\">7123456789ABCDEF</xref>\n\
        <xref offset=\"0x000000000000095A\">8123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000960\">9123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A34\">A123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000A40\">B123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BDC\">C123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000BE0\">D123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C03\">E123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C10\">F123456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C76\">0223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000C80\">1223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000008000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
      <attribute key=\"org_base\">0</attribute>\n\
      <attribute key=\"comb\">2</attribute>\n\
      <attribute key=\"color\">4294967295</attribute>\n\
      <attribute key=\"align\">3</attribute>\n\
      <attribute key=\"start_ea\">134217728</attribute>\n\
      <attribute key=\"perm\">5</attribute>\n\
      <attribute key=\"bitness\">1</attribute>\n\
      <attribute key=\"flags\">16</attribute>\n\
      <attribute key=\"end_ea\">134220955</attribute>\n\
      <attribute key=\"sel\">1</attribute>\n\
      <attribute key=\"type\">2</attribute>\n\
      <blob offset=\"0000000000000012\">5557565381EC4C0100008B8424600100008DA8800000000580800000894424348B842460010000896C24300580000100894424388B84246001000005808001008944243CA1A00C000885C00F8531040000B8D48D000885C07409C70424A40C0008FFD0A1A00C000885C00F84A3010000B8D88D000885C07409C70424A40C0008FFD0C744240800000200C744240400000000892C24E8428D0000C744241C18000000C744242C000000008B44242CC7442424000000008D3C85000000008B6C44308D048504000000897C2428894424208B5C242489D889DAC1F80483E20183E00209D089DA03442428D1FA83E20FC1E00401D089DA8B3C85E07F0008C1E20631DB89542414C1E704897C24188D74260089D889DA0FB64C241CC1F80483E2018B74241883E00209D089DA03442420D1FA83E20FC1E00401D00B3485E07F00088B442414D3E689F1C1E91809D88B3CCDC02C0008C1E00383C3018B0CCDC42C00088D5405008D440504893A890889F1C1E9100FB6C98B3CCDC0340008093A8B0CCDC4340008090889F10FB6CD8B3CCDC03C0008093A8B0CCDC43C0008090889F10FB6F18B0CF5C0440008090A8B14F5C4440008091083FB400F8553FFFFFF8344242401837C2424400F8503FFFFFF8344242C02836C241C08837C242C080F85C8FEFFFF8B842460010000C7809000020000000000C6808E00020000C6808F000200008380980002000181C44C0100005B5E5F5DC3BAC05C0008B90008000089D731DBF3AB8B3C9D208A000889D98D77FF83C70689F2C1FA1FC1EA1D8D041683E00729D00FB680617D000889442414B893244992F7EB89D8C1F81F01DAC1FA0429C26BC21C29C185F60F48F78B048DF07C00088B4C2414C1FE038D347231D2C1E60983C20181FA80000000741685D174F1098496C05C000883C20181FA8000000075EA83C30183FB380F8576FFFFFFBAC04C0008B90004000031C089D7F3AB30DBBF932449928B049D208900088D48FF89C8F7EF89C8C1F81F8D340AC1FE0229C68D04F50000000029F029C1B8ABAAAA2AF7EB89D80FB689617D0008C1F81FC1E609C1FA0229C28D045289DAC1E00329C28B0495807D000831D283C20181FA80000000741685D174F1098496C04C000883C20181FA8000000075EA83C30183FB307583BAC02C0008B90008000031C089D7F3AB30DB8B049D60880008BFABAAAA2A8B3485DC87000883EE0189F083E0070FB688607D000889D8F7EF89D8C1F81F89DFC1EE03C1E609C1FA0229C289D08D145201C6C1E203B8FF00000029D789FAC1E6028DB4260000000085C8740E8B3C95807D000809BCC6C02C000883E80183F8FF75E683C30183FB307589B82F000000EB0B8DB4260000000089C389D08B14856088000883C32F8944943C899C94BC0000008D50FF83FAFF75DFBAC00C0008B90008000031C089D7F3AB31DBBFABAAAA2A8B049DE07D00088B4C843C89C8F7EF89C8C1F81F29C28D045201C029C189D883E01F8B0C8D487D00088B3485E07C000889D8C1F805C1E20701C2B83F000000C1E2028DB60000000085C8740709B4C2C00C000883E80183F8FF75ED83C30183FB40759DC705A00C000801000000E9EEFBFFFFE9FBFBFFFF89F68DBC270000000083EC1CC70424288D0008E861FBFFFF83C41CC38DB6000000008DBC27000000005557565383EC1C8B4424348B5C24308B909800020085D20F84800100000FB6033C5A7F1C3C417D208D50D280FA0B761831C083C41C5B5E5F5DC38DB6000000008D509F80FA1977E80FB6530180FA5A0F8F3701000080FA417D088D4AD280F90B77CE8B4C243438818E0002000F84400100008B4C243489DF31DB88818E00020088918F00020031C90FBE073C608D50C57F0B3C408D50CB0F8E0D01000031C0900FA3C2730A8D34080B1CB5807D000883C00183F80675E983C10683C70183F90C75C68B4424348B7424348B889000020083E8808DAE8080000031D9908D7426008B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80800100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000200908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B44243489989000020083C41CB8010000005B5E5F5DC38D4A9F80F9190F8798FEFFFFE9C5FEFFFF890424E8ABF9FFFFE973FEFFFF8D50D2E9EBFEFFFF8B4C243438918F0002000F85B0FEFFFFB801000000E966FEFFFF8D74260055B9C05C00085731D25631C0538B5C24148B6C24188D76000FB63383C30183E67F0B04B10B94B10002000081C10004000081F9C07C000875DF31F6908D7426000FB60CB5E0890008BF1C00000089C32B3CB5E089000883C508D3E389F9D3E809D889C389C183E37F8B1C9DC0520008C1E91583E17F80CF800B1C8DC04C000889C1C1E90E83E17F0B1C8DC04E000889C1C1E90783E17F0B1C8DC05000080FB60CB5E089000883C601895DF889D3D3E389F9D3EA09DA89D189D383E17F8B0C8DC05A0008C1EB1583E37F80CD800B0C9DC054000889D3C1EB0E83E37F0B0C9DC056000889D3C1EB0783E37F0B0C9DC058000883FE10894DFC0F8543FFFFFF8B442418C78094000200000000005B5E5F5DC35557565383EC108B4C24248B4424288B71048B298B98900002008B790C89F08B510831E821D831C531F089C689F831D021D889F331C731C289E8C1E8038954240CC1EB03896C240489D589FA89042489F8C1ED03C1EA03C1E8098974240883E03F89EE89D58B14C5C028000883E63F83E53F8B04C5C42800080B14EDC02A00080B04EDC42A000889FDC1ED13C1EF1983E53F83E73F0B14EDC02600080B04EDC42600080B14FDC02400080B04FDC42400088B7C240C0B14F5C02200080B04F5C422000889FDC1ED0989EE89FD83E63F0B14F5C02000080B04F5C4200008C1ED1383E33F89EE89FD83E63FC1ED190B14F5C01E00080B04F5C41E000889EE83E63F0B14F5C01C00080B04F5C41C00088B7424080B14DDC01A00080B04DDC41A000889F3C1EB0983E33F0B14DDC01800080B04DDC418000889F3C1EB1383E33F0B14DDC01600080B04DDC416000889F3C1EB1983E33F0B14DDC01400080B04DDC41400088324243F8B7C24048B342489FBC1EB0983E33F0B14F5C01200080B04F5C41200080B14DDC01000080B04DDC410000889FBC1EB1383E33F0B14DDC00E00080B04DDC40E000889FBC1EB1983E33F0B04DDC40C00080B14DDC00C0008894104891183C4105B5E5F5DC38DB600000000555756538B54241C8B7C24208B7424148B6C24180FB6028887800002000FB6420184C075030FB6028B7C2420B91A00000088878100020089FA89F0D3E883E03F83F8258D583B770C8D583583F80C8D782E0F42DF83E90683C201889A8100020083F9FC75D48B54242089EFB91A00000083E70FC1ED02C1E61EC1E70209EE89F0D3E883E03F83F8258D583B770C8D583583F80C8D682E0F42DD83E90683C201889A8600020083F9FC75D483FF258D473B7F0C8D473583FF0C8D572E0F4CC28B74242088868C000200C6868D000200005B5E5F5DC38DB6000000008DBF000000005557565383EC2C8B442448C70424C07C00088B7424448B5C244089442404E84DFAFFFF8B44244885F60F94C28B809400020085C00F94C038C2743A8B542448B80800000089D166908B2A83C2088B7CC138896CC1388B6AFC897AF88B7CC13C896CC13C897AFC83E80175DD8B44244889B09400020031C031ED8DB426000000008B1485608800088B1495DC7E0008807C13FF0074070B2C85807D000883C00183F81875DC31F666908B1485608800088B1495DC7E0008807C13FF0074070B3485207D000883C00183F83075DC30C031FF8B1485608800088B14955C7F0008807C13FF0074070B3C85807D000883C00183F81875DC31C966908B1485608800088B14955C7F0008807C13FF0074070B0C85207D000883C00183F83075DC8B442448897424148D74241089742408C704240100000089442404894C241C896C2410897C2418E8588200008B44244889342489442404E8F8FBFFFF8B4C241031C08B5424148DB600000000850C85E07C00080F95040383C00183F82075ED30C08D7600851485E07C00080F9544032083C00183F82075EC83C42C5B5E5F5DC38D74260083EC1C8B442424C7442408288D0008894424048B442420890424E841FEFFFF83C41CC38DB6000000008DBC27000000005557565383EC2C8B5C24448D6C2418C70424C07C00088B7424408D7C2420895C2404E879F8FFFF89E98DB426000000008D560831C08D760083C60101C00A46FF39F275F4D0E883C1018841FF39F989D675DE895C2404892C24E812FAFFFF83C42C5B5E5F5DC38D76008DBC270000000083EC1C8B442420C7442404288D0008890424E879FFFFFF83C41CC3</blob>\n\
    </version>\n\
  </segment>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/segment/3223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}


TEST_F (TestXMLDatabaseModel, TestOneFile_FileExporter) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
<segment>\n\
  <id>3223456789ABCDEF</id>\n\
  <version>\n\
    <size>0x0000000000000C9B</size>\n\
    <userdefinedname>.text</userdefinedname>\n\
    <xrefs>\n\
      <xref offset=\"0x0000000000000000\">0123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000487\">1123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000490\">2123456789ABCDEF</xref>\n\
      <xref offset=\"0x00000000000004A3\">3123456789ABCDEF</xref>\n\
      <xref offset=\"0x00000000000004B0\">4123456789ABCDEF</xref>\n\
      <xref offset=\"0x000000000000067C\">5123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000680\">6123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000790\">7123456789ABCDEF</xref>\n\
      <xref offset=\"0x000000000000095A\">8123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000960\">9123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000A34\">A123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000A40\">B123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000BDC\">C123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000BE0\">D123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C03\">E123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C10\">F123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C76\">0223456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C80\">1223456789ABCDEF</xref>\n\
    </xrefs>\n\
    <matchingsystem>\n\
      <address>0000000008000000</address>\n\
      <equipment>None</equipment>\n\
      <os>None</os>\n\
    </matchingsystem>\n\
    <attribute key=\"org_base\">0</attribute>\n\
    <attribute key=\"comb\">2</attribute>\n\
    <attribute key=\"color\">4294967295</attribute>\n\
    <attribute key=\"align\">3</attribute>\n\
    <attribute key=\"start_ea\">134217728</attribute>\n\
    <attribute key=\"perm\">5</attribute>\n\
    <attribute key=\"bitness\">1</attribute>\n\
    <attribute key=\"flags\">16</attribute>\n\
    <attribute key=\"end_ea\">134220955</attribute>\n\
    <attribute key=\"sel\">1</attribute>\n\
    <attribute key=\"type\">2</attribute>\n\
  </version>\n\
</segment>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    auto model1 = MakeXmlFilesDatabaseModel(input_files);
    EXPECT_NO_THROW(model1->accept(visitor));

    EXPECT_FALSE(call_queue->empty());
    string output_path("output.xml");
    auto visitor_2 = MakeFileXmlExporter(output_path);
    auto model2 = MakeXmlFilesDatabaseModel(input_files);
    EXPECT_NO_THROW(model2->accept(*visitor_2));
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open(output_path);
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}


TEST_F (TestXMLDatabaseModel, TestOneFileWithBlob_FileExporter) {
    path filename("0123456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
<segment>\n\
  <id>3223456789ABCDEF</id>\n\
  <version>\n\
    <size>0x0000000000000C9B</size>\n\
    <userdefinedname>.text</userdefinedname>\n\
    <xrefs>\n\
      <xref offset=\"0x0000000000000000\">0123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000487\">1123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000490\">2123456789ABCDEF</xref>\n\
      <xref offset=\"0x00000000000004A3\">3123456789ABCDEF</xref>\n\
      <xref offset=\"0x00000000000004B0\">4123456789ABCDEF</xref>\n\
      <xref offset=\"0x000000000000067C\">5123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000680\">6123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000790\">7123456789ABCDEF</xref>\n\
      <xref offset=\"0x000000000000095A\">8123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000960\">9123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000A34\">A123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000A40\">B123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000BDC\">C123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000BE0\">D123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C03\">E123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C10\">F123456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C76\">0223456789ABCDEF</xref>\n\
      <xref offset=\"0x0000000000000C80\">1223456789ABCDEF</xref>\n\
    </xrefs>\n\
    <matchingsystem>\n\
      <address>0000000008000000</address>\n\
      <equipment>None</equipment>\n\
      <os>None</os>\n\
    </matchingsystem>\n\
    <attribute key=\"org_base\">0</attribute>\n\
    <attribute key=\"comb\">2</attribute>\n\
    <attribute key=\"color\">4294967295</attribute>\n\
    <attribute key=\"align\">3</attribute>\n\
    <attribute key=\"start_ea\">134217728</attribute>\n\
    <attribute key=\"perm\">5</attribute>\n\
    <attribute key=\"bitness\">1</attribute>\n\
    <attribute key=\"flags\">16</attribute>\n\
    <attribute key=\"end_ea\">134220955</attribute>\n\
    <attribute key=\"sel\">1</attribute>\n\
    <attribute key=\"type\">2</attribute>\n\
    <blob offset=\"0000000000000012\">5557565381EC4C0100008B8424600100008DA8800000000580800000894424348B842460010000896C24300580000100894424388B84246001000005808001008944243CA1A00C000885C00F8531040000B8D48D000885C07409C70424A40C0008FFD0A1A00C000885C00F84A3010000B8D88D000885C07409C70424A40C0008FFD0C744240800000200C744240400000000892C24E8428D0000C744241C18000000C744242C000000008B44242CC7442424000000008D3C85000000008B6C44308D048504000000897C2428894424208B5C242489D889DAC1F80483E20183E00209D089DA03442428D1FA83E20FC1E00401D089DA8B3C85E07F0008C1E20631DB89542414C1E704897C24188D74260089D889DA0FB64C241CC1F80483E2018B74241883E00209D089DA03442420D1FA83E20FC1E00401D00B3485E07F00088B442414D3E689F1C1E91809D88B3CCDC02C0008C1E00383C3018B0CCDC42C00088D5405008D440504893A890889F1C1E9100FB6C98B3CCDC0340008093A8B0CCDC4340008090889F10FB6CD8B3CCDC03C0008093A8B0CCDC43C0008090889F10FB6F18B0CF5C0440008090A8B14F5C4440008091083FB400F8553FFFFFF8344242401837C2424400F8503FFFFFF8344242C02836C241C08837C242C080F85C8FEFFFF8B842460010000C7809000020000000000C6808E00020000C6808F000200008380980002000181C44C0100005B5E5F5DC3BAC05C0008B90008000089D731DBF3AB8B3C9D208A000889D98D77FF83C70689F2C1FA1FC1EA1D8D041683E00729D00FB680617D000889442414B893244992F7EB89D8C1F81F01DAC1FA0429C26BC21C29C185F60F48F78B048DF07C00088B4C2414C1FE038D347231D2C1E60983C20181FA80000000741685D174F1098496C05C000883C20181FA8000000075EA83C30183FB380F8576FFFFFFBAC04C0008B90004000031C089D7F3AB30DBBF932449928B049D208900088D48FF89C8F7EF89C8C1F81F8D340AC1FE0229C68D04F50000000029F029C1B8ABAAAA2AF7EB89D80FB689617D0008C1F81FC1E609C1FA0229C28D045289DAC1E00329C28B0495807D000831D283C20181FA80000000741685D174F1098496C04C000883C20181FA8000000075EA83C30183FB307583BAC02C0008B90008000031C089D7F3AB30DB8B049D60880008BFABAAAA2A8B3485DC87000883EE0189F083E0070FB688607D000889D8F7EF89D8C1F81F89DFC1EE03C1E609C1FA0229C289D08D145201C6C1E203B8FF00000029D789FAC1E6028DB4260000000085C8740E8B3C95807D000809BCC6C02C000883E80183F8FF75E683C30183FB307589B82F000000EB0B8DB4260000000089C389D08B14856088000883C32F8944943C899C94BC0000008D50FF83FAFF75DFBAC00C0008B90008000031C089D7F3AB31DBBFABAAAA2A8B049DE07D00088B4C843C89C8F7EF89C8C1F81F29C28D045201C029C189D883E01F8B0C8D487D00088B3485E07C000889D8C1F805C1E20701C2B83F000000C1E2028DB60000000085C8740709B4C2C00C000883E80183F8FF75ED83C30183FB40759DC705A00C000801000000E9EEFBFFFFE9FBFBFFFF89F68DBC270000000083EC1CC70424288D0008E861FBFFFF83C41CC38DB6000000008DBC27000000005557565383EC1C8B4424348B5C24308B909800020085D20F84800100000FB6033C5A7F1C3C417D208D50D280FA0B761831C083C41C5B5E5F5DC38DB6000000008D509F80FA1977E80FB6530180FA5A0F8F3701000080FA417D088D4AD280F90B77CE8B4C243438818E0002000F84400100008B4C243489DF31DB88818E00020088918F00020031C90FBE073C608D50C57F0B3C408D50CB0F8E0D01000031C0900FA3C2730A8D34080B1CB5807D000883C00183F80675E983C10683C70183F90C75C68B4424348B7424348B889000020083E8808DAE8080000031D9908D7426008B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80800100908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B7424348DAE80000200908B700483C0088B78F889F231FA21CA31D731F28978F839E88950FC75E38B44243489989000020083C41CB8010000005B5E5F5DC38D4A9F80F9190F8798FEFFFFE9C5FEFFFF890424E8ABF9FFFFE973FEFFFF8D50D2E9EBFEFFFF8B4C243438918F0002000F85B0FEFFFFB801000000E966FEFFFF8D74260055B9C05C00085731D25631C0538B5C24148B6C24188D76000FB63383C30183E67F0B04B10B94B10002000081C10004000081F9C07C000875DF31F6908D7426000FB60CB5E0890008BF1C00000089C32B3CB5E089000883C508D3E389F9D3E809D889C389C183E37F8B1C9DC0520008C1E91583E17F80CF800B1C8DC04C000889C1C1E90E83E17F0B1C8DC04E000889C1C1E90783E17F0B1C8DC05000080FB60CB5E089000883C601895DF889D3D3E389F9D3EA09DA89D189D383E17F8B0C8DC05A0008C1EB1583E37F80CD800B0C9DC054000889D3C1EB0E83E37F0B0C9DC056000889D3C1EB0783E37F0B0C9DC058000883FE10894DFC0F8543FFFFFF8B442418C78094000200000000005B5E5F5DC35557565383EC108B4C24248B4424288B71048B298B98900002008B790C89F08B510831E821D831C531F089C689F831D021D889F331C731C289E8C1E8038954240CC1EB03896C240489D589FA89042489F8C1ED03C1EA03C1E8098974240883E03F89EE89D58B14C5C028000883E63F83E53F8B04C5C42800080B14EDC02A00080B04EDC42A000889FDC1ED13C1EF1983E53F83E73F0B14EDC02600080B04EDC42600080B14FDC02400080B04FDC42400088B7C240C0B14F5C02200080B04F5C422000889FDC1ED0989EE89FD83E63F0B14F5C02000080B04F5C4200008C1ED1383E33F89EE89FD83E63FC1ED190B14F5C01E00080B04F5C41E000889EE83E63F0B14F5C01C00080B04F5C41C00088B7424080B14DDC01A00080B04DDC41A000889F3C1EB0983E33F0B14DDC01800080B04DDC418000889F3C1EB1383E33F0B14DDC01600080B04DDC416000889F3C1EB1983E33F0B14DDC01400080B04DDC41400088324243F8B7C24048B342489FBC1EB0983E33F0B14F5C01200080B04F5C41200080B14DDC01000080B04DDC410000889FBC1EB1383E33F0B14DDC00E00080B04DDC40E000889FBC1EB1983E33F0B04DDC40C00080B14DDC00C0008894104891183C4105B5E5F5DC38DB600000000555756538B54241C8B7C24208B7424148B6C24180FB6028887800002000FB6420184C075030FB6028B7C2420B91A00000088878100020089FA89F0D3E883E03F83F8258D583B770C8D583583F80C8D782E0F42DF83E90683C201889A8100020083F9FC75D48B54242089EFB91A00000083E70FC1ED02C1E61EC1E70209EE89F0D3E883E03F83F8258D583B770C8D583583F80C8D682E0F42DD83E90683C201889A8600020083F9FC75D483FF258D473B7F0C8D473583FF0C8D572E0F4CC28B74242088868C000200C6868D000200005B5E5F5DC38DB6000000008DBF000000005557565383EC2C8B442448C70424C07C00088B7424448B5C244089442404E84DFAFFFF8B44244885F60F94C28B809400020085C00F94C038C2743A8B542448B80800000089D166908B2A83C2088B7CC138896CC1388B6AFC897AF88B7CC13C896CC13C897AFC83E80175DD8B44244889B09400020031C031ED8DB426000000008B1485608800088B1495DC7E0008807C13FF0074070B2C85807D000883C00183F81875DC31F666908B1485608800088B1495DC7E0008807C13FF0074070B3485207D000883C00183F83075DC30C031FF8B1485608800088B14955C7F0008807C13FF0074070B3C85807D000883C00183F81875DC31C966908B1485608800088B14955C7F0008807C13FF0074070B0C85207D000883C00183F83075DC8B442448897424148D74241089742408C704240100000089442404894C241C896C2410897C2418E8588200008B44244889342489442404E8F8FBFFFF8B4C241031C08B5424148DB600000000850C85E07C00080F95040383C00183F82075ED30C08D7600851485E07C00080F9544032083C00183F82075EC83C42C5B5E5F5DC38D74260083EC1C8B442424C7442408288D0008894424048B442420890424E841FEFFFF83C41CC38DB6000000008DBC27000000005557565383EC2C8B5C24448D6C2418C70424C07C00088B7424408D7C2420895C2404E879F8FFFF89E98DB426000000008D560831C08D760083C60101C00A46FF39F275F4D0E883C1018841FF39F989D675DE895C2404892C24E812FAFFFF83C42C5B5E5F5DC38D76008DBC270000000083EC1C8B442420C7442404288D0008890424E879FFFFFF83C41CC3</blob>\n\
  </version>\n\
</segment>\n\
</sigfile>";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    auto model = MakeXmlFilesDatabaseModel(input_files);
    EXPECT_NO_THROW(model->accept(visitor));

    EXPECT_FALSE(call_queue->empty());
    string output_path("output.xml");
    auto visitor_2 = MakeFileXmlExporter(output_path);
    auto model2 = MakeXmlFilesDatabaseModel(input_files);
    EXPECT_NO_THROW(model2->accept(*visitor_2));
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open(output_path);
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}


TEST_F (TestXMLDatabaseModel, TestOneFileWithComments) {
    path filename("4223456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>4223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000002E</size>\n\
      <userdefinedname flags=\"0x00000054\">uuu</userdefinedname>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">47BDE8AB</signature>\n\
      </signatures>\n\
      <offsets>\n\
        <comments offset=\"0000000000000002\" type=\"repeatable_comment\">cmt 1</comments>\n\
        <comments offset=\"0000000000000004\" type=\"repeatable_comment\">cmt 2</comments>\n\
        <comments offset=\"0000000000000005\" type=\"nonrepeatable_comment\">cmt 3</comments>\n\
        <comments offset=\"0000000000000006\" type=\"repeatable_comment\">repeatable_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"nonrepeatable_comment\">nonrepeatable_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"anterior_comment\">anterior_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"posterior_comment\">posterior_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"bookmark\">bookmark: comment</comments>\n\
        <comments offset=\"0000000000000007\" type=\"nonrepeatable_comment\">cmt 4</comments>\n\
      </offsets>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000016\">5223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\">6223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000000000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>\n\
";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/basic_block/4223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}


TEST_F (TestXMLDatabaseModel, TestOneFileWithCommentsThroughMemory) {
    path filename("4223456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>4223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000002E</size>\n\
      <userdefinedname flags=\"0x00000054\">uuu</userdefinedname>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">47BDE8AB</signature>\n\
      </signatures>\n\
      <offsets>\n\
        <comments offset=\"0000000000000002\" type=\"repeatable_comment\">cmt 1</comments>\n\
        <comments offset=\"0000000000000004\" type=\"repeatable_comment\">cmt 2</comments>\n\
        <comments offset=\"0000000000000005\" type=\"nonrepeatable_comment\">cmt 3</comments>\n\
        <comments offset=\"0000000000000006\" type=\"repeatable_comment\">repeatable_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"nonrepeatable_comment\">nonrepeatable_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"anterior_comment\">anterior_comment: comment</comments>\n\
        <comments offset=\"0000000000000006\" type=\"posterior_comment\">posterior_comment: comment </comments>\n\
        <comments offset=\"0000000000000006\" type=\"bookmark\">bookmark : comment</comments>\n\
        <comments offset=\"0000000000000007\" type=\"nonrepeatable_comment\">cmt 4</comments>\n\
      </offsets>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000016\">5223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\">6223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000000000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>\n\
";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    auto visitor_model = MakeModel();
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_model.visitor);

    visitor_model.model->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/basic_block/4223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}

TEST_F(TestXMLDatabaseModel, test_xml_escape) {
    path filename("4223456789ABCDEF.xml");
    auto visitor = MakeFileXmlExporter(filename.string());
    EXPECT_NO_THROW(visitor->visit_start());
    EXPECT_NO_THROW(visitor->visit_start_reference_object(OBJECT_TYPE_BASIC_BLOCK));
    EXPECT_NO_THROW(visitor->visit_offset_comments(12, COMMENT_REPEATABLE, make_string_ref("pl<op")));
    EXPECT_NO_THROW(visitor->visit_offset_comments(12, COMMENT_REPEATABLE, make_string_ref("plop\xe2")));
    EXPECT_NO_THROW(visitor->visit_offset_comments(12, COMMENT_REPEATABLE, make_string_ref("plo>pÔ")));
    EXPECT_NO_THROW(visitor->visit_end_reference_object());
    EXPECT_NO_THROW(visitor->visit_end());

}



TEST_F (TestXMLDatabaseModel, TestOneFileWithXrefs) {
    path filename("4223456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>4223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000002E</size>\n\
      <userdefinedname flags=\"0x00000054\">uuu</userdefinedname>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">47BDE8AB</signature>\n\
      </signatures>\n\
      <offsets/>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000016\">5223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\">6223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\" operand=\"0x0000000000000001\">7223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\" operand=\"0x0000000000000001\">8223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\">9223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\">A223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000000000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>\n\
";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/basic_block/4223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}


TEST_F (TestXMLDatabaseModel, TestOneFileWithXrefsThroughMemory) {
    path filename("4223456789ABCDEF.xml");

    std::ofstream test_input;
    test_input.open(filename.string());
    test_input << "<?xml version=\"1.0\" encoding=\"iso-8859-15\"?>\n\
<sigfile>\n\
  <basic_block>\n\
    <id>4223456789ABCDEF</id>\n\
    <version>\n\
      <size>0x000000000000002E</size>\n\
      <userdefinedname flags=\"0x00000054\">uuu</userdefinedname>\n\
      <signatures>\n\
        <signature algo=\"crc32\" method=\"firstbyte\">47BDE8AB</signature>\n\
      </signatures>\n\
      <xrefs>\n\
        <xref offset=\"0x0000000000000016\">5223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\">6223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000020\" operand=\"0x0000000000000001\">7223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\">9223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\">A223456789ABCDEF</xref>\n\
        <xref offset=\"0x0000000000000030\" operand=\"0x0000000000000001\">8223456789ABCDEF</xref>\n\
      </xrefs>\n\
      <matchingsystem>\n\
        <address>0000000000000000</address>\n\
        <equipment>None</equipment>\n\
        <os>None</os>\n\
      </matchingsystem>\n\
    </version>\n\
  </basic_block>\n\
</sigfile>\n\
";
    test_input.close();

    auto call_queue = make_shared<std::queue<std::string>>();
    TestDatabaseModelVisitor visitor(call_queue);
    std::vector<std::string> input_files {filename.string()};

    MakeXmlFilesDatabaseModel(input_files)->accept(visitor);

    EXPECT_FALSE(call_queue->empty());
    string output_path("output");
    auto visitor_2 = MakeXmlExporter(output_path);
    auto visitor_model = MakeModel();
    MakeXmlFilesDatabaseModel(input_files)->accept(*visitor_model.visitor);

    visitor_model.model->accept(*visitor_2);
    ifstream output1;
    output1.open(filename.string());

    ifstream output2;
    output2.open("output/basic_block/4223456789ABCDEF.xml");
    while(!output1.eof()) {
        string line1;
        string line2;
        getline(output1, line1);
        getline(output2, line2);
        EXPECT_STREQ(line1.c_str(), line2.c_str());
    }
}

